一点からみて　十字に方向確認する

同じ色があるところはtrueにする

繰り返し

この方法だと２つ以降の先がだるい


/--------------------------------------------------------------------------------------------------


方法２、
y軸でぷよをみる
この手法だとUの字型でも一点からtrueを返すことで
そこからy軸に配列を見ていく

まず色をみて現在つながりを見ているぷよと同じ色の場合に次に進む
次にその周囲にtrueがあればつながっているのでその調べているブロックをtrueにします
その次にこの条件がtrueになっていればそこから十字にみて同じ色のぷよがあった時trueを返します
この過程を配列分繰り返せばつながっているかどうかがわかる

ただこの方法はループ数がかなり多くなるのでintにしてつながりを明確にする必要がある可能性あり


/-------------------------------------------------------------------------------------------------------

方法３、
各データに関連データを内蔵しておく（めんどそう）

各ぷよに現在の関連を格納
例、赤赤　の場合　両方に２を格納　２つのつながりのため

なおこれだと分かれているつながりの区別ができないため
区別するための何かを付属につけておく
例、赤赤　赤赤
    2.A   2.B

基本的に落ちてきたぷよからの判定で通常は進行する（なぜ今までやらなかった。。。。）
この作業だと調べた箇所と同じ色、記号、またつながりで周りを調べることができるはず、
例、赤赤L R 
	赤	Lが赤だった場合十字に見て色が同じでなおかつその場所のつながりの総数から
		消すか消さないかの判断が可能
		調べたぷよから順にマップに格納していくことで取りこぼしもないはず、
		
値の結合の仕方
   R
赤 L 赤		この時左の赤は,1.Aという情報、右の赤は1.Bという情報にしておく
		Lが左と右に同じ色を感知してなお４未満であった場合
		ABを比べ低い数値の方で統一し3.Aという形にする

ぷよ一つに必要な情報

色、
つながりの関連の数値
{
	つながりの数
	群の関連
}

構造体配列作ればよかろう

次にこの初期化方法

いつも通り上から配列を見ていく

その座標の色をみてその座標につながりと群を関連つけていく
例、赤 N 赤 青
　　1A   1B 1A

最初に難易度に合わせて数ぶんの群用配列を動的に確保するとよいかな？
例、赤[群の最大生産数]
	赤[0].つながり = 1;
	赤[0].群 = A;
	赤[0].現在使われているか

配列で色とその場所の配列を関連つけることにする
例、赤.1 N 赤.2 N 赤.3





